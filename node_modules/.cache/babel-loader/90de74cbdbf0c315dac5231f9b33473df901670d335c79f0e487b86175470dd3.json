{"ast":null,"code":"var _jsxFileName = \"/Users/yashagrawal/Documents/Northwestern/Fall2023/CS338/InterviewPrep/src/components/Evaluation.js\",\n  _s2 = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport { sendMessageToAI } from \"../utils/GptAPI\";\nimport Scorecard from './Scorecard';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Evaluation = ({\n  messages\n}) => {\n  _s2();\n  var _s = $RefreshSig$();\n  const [gptMessages, setGptMessages] = useState(\"\");\n  _s(useEffect(_s(() => {\n    _s();\n    const createTranscript = messages => {\n      return messages.slice(1).map(msg => `${msg.role}: ${msg.content}`).join('\\n');\n    };\n    const fetchEvaluation = async () => {\n      const transcript = createTranscript(messages);\n      const initialContext = {\n        role: \"system\",\n        content: \"You are a lead software engineer at a major tech company.\" + \" You are being given a transcript from a recent interview between a software developer at your company and a candidate for a Software Engineering role.\" + \" Evaluate the candidate based on 8 factors: Motivation, Ability to be Proactive, Able to work in an unstructured environment, Perseverance, Conflict Resolution, Empathy, Growth, and Communication.\" + \" You are ONLY EVALUATING the USER.\" + \" Give scores ranging from 1-10 for each factor, where 1 represents poor showing of this element in their answers and 10 represents amazing representation of this element in their answers.\" + \" If there was not enough data to evaluate the candidate for a certain element, say \\\"Not Enough Data\\\"\" + \" After evaluationg, give one paragraph on what was GENUINELY done well in their answers.\" + \" Give one more paragraph on what needs improving in their answers.\"\n      };\n      const interviewTranscript = {\n        role: \"user\",\n        content: transcript\n      };\n      console.log([initialContext, interviewTranscript]);\n\n      // Now call the API and wait for the response before setting the state\n      const response = await gptCall([initialContext, interviewTranscript]);\n      if (response) {\n        // Make sure there's a response before setting state\n        setGptMessages(response);\n        console.log(response);\n      }\n    };\n    const parseScores = () => {\n      const scores = {};\n      const lines = gptMessages.split('\\n');\n      lines.forEach(line => {\n        const [category, score] = line.split(':').map(s => s.trim());\n        scores[category] = score;\n      });\n      return scores;\n    };\n    fetchEvaluation();\n    const [scores, setScores] = useState(() => parseScores());\n  }, \"LcLCNH8jGroOiwR81aEWOfy0z60=\"), []), \"LcLCNH8jGroOiwR81aEWOfy0z60=\");\n  const gptCall = async newMessages => {\n    try {\n      const responseText = await sendMessageToAI(newMessages, 'gpt-4-1106-preview', 500);\n      return responseText;\n    } catch (error) {\n      console.error('Error:', error);\n      return \"\";\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(Scorecard, {\n      scores: scores\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 69,\n    columnNumber: 5\n  }, this);\n};\n_s2(Evaluation, \"RoyQNhsVCkXRLCJZUkjX+WuHy2U=\");\n_c = Evaluation;\nexport default Evaluation;\nvar _c;\n$RefreshReg$(_c, \"Evaluation\");","map":{"version":3,"names":["React","useState","useEffect","sendMessageToAI","Scorecard","jsxDEV","_jsxDEV","Evaluation","messages","_s2","_s","$RefreshSig$","gptMessages","setGptMessages","createTranscript","slice","map","msg","role","content","join","fetchEvaluation","transcript","initialContext","interviewTranscript","console","log","response","gptCall","parseScores","scores","lines","split","forEach","line","category","score","s","trim","setScores","newMessages","responseText","error","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/yashagrawal/Documents/Northwestern/Fall2023/CS338/InterviewPrep/src/components/Evaluation.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { sendMessageToAI } from \"../utils/GptAPI\";\nimport Scorecard from './Scorecard';\n\nconst Evaluation = ({ messages }) => {\n  const [gptMessages, setGptMessages] = useState(\"\");\n\n  useEffect(() => {\n    const createTranscript = (messages) => {\n      return messages.slice(1).map((msg) => `${msg.role}: ${msg.content}`).join('\\n');\n    };\n\n    const fetchEvaluation = async () => {\n      const transcript = createTranscript(messages);\n\n      const initialContext = {\n        role: \"system\",\n        content: \"You are a lead software engineer at a major tech company.\" +\n        \" You are being given a transcript from a recent interview between a software developer at your company and a candidate for a Software Engineering role.\" +\n        \" Evaluate the candidate based on 8 factors: Motivation, Ability to be Proactive, Able to work in an unstructured environment, Perseverance, Conflict Resolution, Empathy, Growth, and Communication.\" +\n        \" You are ONLY EVALUATING the USER.\" + \n        \" Give scores ranging from 1-10 for each factor, where 1 represents poor showing of this element in their answers and 10 represents amazing representation of this element in their answers.\" + \n        \" If there was not enough data to evaluate the candidate for a certain element, say \\\"Not Enough Data\\\"\" + \n        \" After evaluationg, give one paragraph on what was GENUINELY done well in their answers.\" +\n        \" Give one more paragraph on what needs improving in their answers.\"\n      };\n\n      const interviewTranscript = {\n        role: \"user\",\n        content: transcript\n      };\n\n      console.log([initialContext, interviewTranscript])\n\n      // Now call the API and wait for the response before setting the state\n      const response = await gptCall([initialContext, interviewTranscript]);\n      if (response) { // Make sure there's a response before setting state\n        setGptMessages(response);\n        console.log(response)\n      }\n    };\n\n    const parseScores = () => {\n      const scores = {};\n      const lines = gptMessages.split('\\n');\n      lines.forEach(line => {\n        const [category, score] = line.split(':').map(s => s.trim());\n        scores[category] = score;\n      });\n      return scores;\n    };\n\n    \n    fetchEvaluation();\n    const [scores, setScores] = useState(() => parseScores());\n  }, []);\n\n  const gptCall = async (newMessages) => {\n    try {\n      const responseText = await sendMessageToAI(newMessages, 'gpt-4-1106-preview', 500);\n      return responseText;\n    } catch (error) {\n      console.error('Error:', error);\n      return \"\";\n    }\n  };\n\n  return (\n    <div>\n      <Scorecard scores={scores} />\n    </div>\n  );\n};\n\nexport default Evaluation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}