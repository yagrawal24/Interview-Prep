{"ast":null,"code":"var _jsxFileName = \"/Users/yashagrawal/Documents/Northwestern/Fall2023/CS338/InterviewPrep/src/components/Evaluation.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport { sendMessageToAI } from \"../utils/GptAPI\";\nimport Scorecard from './Scorecard';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Evaluation = ({\n  messages\n}) => {\n  _s();\n  const [gptMessages, setGptMessages] = useState(\"\");\n  useEffect(() => {\n    const createTranscript = messages => {\n      return messages.slice(1).map(msg => `${msg.role}: ${msg.content}`).join('\\n');\n    };\n    const fetchEvaluation = async () => {\n      const transcript = createTranscript(messages);\n      const initialContext = {\n        role: \"system\",\n        content: \"You are a lead software engineer at a major tech company.\" + \" You are being given a transcript from a recent interview between a software developer at your company and a candidate for a Software Engineering role.\" + \" Evaluate the candidate based on 8 factors: Motivation, Ability to be Proactive, Able to work in an unstructured environment, Perseverance, Conflict Resolution, Empathy, Growth, and Communication.\" + \" You are ONLY EVALUATING the USER.\" + \" Give scores ranging from 1-10 for each factor, where 1 represents poor showing of this element in their answers and 10 represents amazing representation of this element in their answers.\" + \" If there was not enough data to evaluate the candidate for a certain element, say \\\"Not Enough Data\\\"\" + \" After evaluationg, give one paragraph on what was GENUINELY done well in their answers.\" + \" Give one more paragraph on what needs improving in their answers.\"\n      };\n      const interviewTranscript = {\n        role: \"user\",\n        content: transcript\n      };\n      console.log([initialContext, interviewTranscript]);\n\n      // Now call the API and wait for the response before setting the state\n      const response = await gptCall([initialContext, interviewTranscript]);\n      if (response) {\n        // Make sure there's a response before setting state\n        setGptMessages(response);\n        console.log(response);\n      }\n    };\n    fetchEvaluation();\n  }, []);\n  const formatResponse = response => {\n    const responseParts = response.split('\\n\\n');\n    return responseParts.map((part, index) => /*#__PURE__*/_jsxDEV(SectionContent, {\n      children: part\n    }, index, false, {\n      fileName: _jsxFileName,\n      lineNumber: 50,\n      columnNumber: 7\n    }, this));\n  };\n  const gptCall = async newMessages => {\n    try {\n      const responseText = await sendMessageToAI(newMessages, 'gpt-4-1106-preview', 500);\n      return responseText;\n    } catch (error) {\n      console.error('Error:', error);\n      return \"\";\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(StyledResponse, {\n    children: gptMessages && formatResponse(gptMessages).map((section, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(SectionTitle, {\n        children: [\"Section \", index + 1]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 70,\n        columnNumber: 11\n      }, this), section]\n    }, index, true, {\n      fileName: _jsxFileName,\n      lineNumber: 69,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 67,\n    columnNumber: 5\n  }, this);\n};\n_s(Evaluation, \"RoyQNhsVCkXRLCJZUkjX+WuHy2U=\");\n_c = Evaluation;\nexport default Evaluation;\nvar _c;\n$RefreshReg$(_c, \"Evaluation\");","map":{"version":3,"names":["React","useState","useEffect","sendMessageToAI","Scorecard","jsxDEV","_jsxDEV","Evaluation","messages","_s","gptMessages","setGptMessages","createTranscript","slice","map","msg","role","content","join","fetchEvaluation","transcript","initialContext","interviewTranscript","console","log","response","gptCall","formatResponse","responseParts","split","part","index","SectionContent","children","fileName","_jsxFileName","lineNumber","columnNumber","newMessages","responseText","error","StyledResponse","section","SectionTitle","_c","$RefreshReg$"],"sources":["/Users/yashagrawal/Documents/Northwestern/Fall2023/CS338/InterviewPrep/src/components/Evaluation.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { sendMessageToAI } from \"../utils/GptAPI\";\nimport Scorecard from './Scorecard';\n\nconst Evaluation = ({ messages }) => {\n  const [gptMessages, setGptMessages] = useState(\"\");\n\n  useEffect(() => {\n    const createTranscript = (messages) => {\n      return messages.slice(1).map((msg) => `${msg.role}: ${msg.content}`).join('\\n');\n    };\n\n    const fetchEvaluation = async () => {\n      const transcript = createTranscript(messages);\n\n      const initialContext = {\n        role: \"system\",\n        content: \"You are a lead software engineer at a major tech company.\" +\n        \" You are being given a transcript from a recent interview between a software developer at your company and a candidate for a Software Engineering role.\" +\n        \" Evaluate the candidate based on 8 factors: Motivation, Ability to be Proactive, Able to work in an unstructured environment, Perseverance, Conflict Resolution, Empathy, Growth, and Communication.\" +\n        \" You are ONLY EVALUATING the USER.\" + \n        \" Give scores ranging from 1-10 for each factor, where 1 represents poor showing of this element in their answers and 10 represents amazing representation of this element in their answers.\" + \n        \" If there was not enough data to evaluate the candidate for a certain element, say \\\"Not Enough Data\\\"\" + \n        \" After evaluationg, give one paragraph on what was GENUINELY done well in their answers.\" +\n        \" Give one more paragraph on what needs improving in their answers.\"\n      };\n\n      const interviewTranscript = {\n        role: \"user\",\n        content: transcript\n      };\n\n      console.log([initialContext, interviewTranscript])\n\n      // Now call the API and wait for the response before setting the state\n      const response = await gptCall([initialContext, interviewTranscript]);\n      if (response) { // Make sure there's a response before setting state\n        setGptMessages(response);\n        console.log(response)\n      }\n    };\n\n    fetchEvaluation();\n  }, []);\n\n\n  const formatResponse = (response) => {\n    const responseParts = response.split('\\n\\n');\n    return responseParts.map((part, index) => (\n      <SectionContent key={index}>\n        {part}\n      </SectionContent>\n    ));\n  };\n\n  const gptCall = async (newMessages) => {\n    try {\n      const responseText = await sendMessageToAI(newMessages, 'gpt-4-1106-preview', 500);\n      return responseText;\n    } catch (error) {\n      console.error('Error:', error);\n      return \"\";\n    }\n  };\n\n  return (\n    <StyledResponse>\n      {gptMessages && formatResponse(gptMessages).map((section, index) => (\n        <div key={index}>\n          <SectionTitle>Section {index + 1}</SectionTitle>\n          {section}\n        </div>\n      ))}\n    </StyledResponse>\n  );\n};\n\nexport default Evaluation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}